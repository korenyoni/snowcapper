// Code generated by go-bindata. DO NOT EDIT.
//  memcopy: true
//  compress: true
//  decompress: once
//  metadata: true
//  asset-dir: true
//  restore: true
// sources:
//  config.snc

package main

import (
	"bytes"
	"compress/flate"
	"io"
	"os"
	"path/filepath"
	"strings"
	"sync"
	"time"

	"github.com/tmthrgd/go-bindata/restore"
)

type asset struct {
	name string
	data string
	size int64
	mode os.FileMode
	time time.Time

	once  sync.Once
	bytes []byte
	err   error
}

func (a *asset) Name() string {
	return a.name
}

func (a *asset) Size() int64 {
	return a.size
}

func (a *asset) Mode() os.FileMode {
	return a.mode
}

func (a *asset) ModTime() time.Time {
	return a.time
}

func (*asset) IsDir() bool {
	return false
}

func (*asset) Sys() interface{} {
	return nil
}

// _bindata is a table, holding each asset generator, mapped to its name.
var _bindata = map[string]*asset{
	"config.snc": &asset{
		name: "config.snc",
		data: "" +
			"\x74\x92\xdf\x6e\xe3\x2c\x10\xc5\xef\xf3\x14\x23\xdf\xd7\x76\x12\xdb\x89\x90\xfa\x2c\xd6\x00\x43" +
			"\x8c\xca\x3f\xc1\x24\x4a\xbf\x6f\xf7\xdd\x57\x8e\x53\xcb\x6d\x76\xf1\x85\x35\x87\x1f\xe7\xc0\x00" +
			"\xdd\x99\x82\x2e\x62\x07\xf0\x06\x25\x2b\x01\x0d\xfb\xd4\xd0\x1d\x7d\x72\x54\x9a\x9b\xf5\x75\x09" +
			"\x6a\x97\x50\x7d\xe0\x85\x9e\x60\x40\x4f\x02\x6e\x78\x75\xbc\x03\x00\x90\x36\x60\xb6\xcb\xec\x3c" +
			"\x5e\x89\x79\xf8\xa8\x49\x40\x7b\xea\xfb\x55\x7a\x24\x4e\xcc\xa9\x88\xa6\xc9\xe4\x08\x0b\x95\x7a" +
			"\xc2\x32\x59\x15\x73\xaa\x55\xf4\xcd\xc3\xa4\x69\xeb\x7d\x5b\xb7\x4b\x31\x2e\xc5\xe8\x6c\xb8\xde" +
			"\x47\xf4\x7a\xe8\xea\xff\x6c\xda\xba\x8e\xb3\x87\x00\x1c\x64\x27\x07\x2d\xf7\xc7\x83\x39\x4a\x49" +
			"\x83\x91\xf2\x74\x32\xa7\xe1\x70\x38\x1b\x83\x5d\x2f\x75\xdf\x63\x8f\x7b\x94\xe7\xa3\x31\x6d\x77" +
			"\x54\x07\x35\x0c\xbd\x3a\x9a\x1e\x4f\x5d\xb7\x5a\x9a\x98\x3d\xb2\x80\xaf\x18\x63\xdd\xf6\xb8\x09" +
			"\x79\x12\xd0\x10\xab\xe7\x76\x55\x0c\xc6\x5e\xea\x49\xb9\x97\xe3\xb7\xed\x2a\xa9\x18\x98\x02\x0b" +
			"\xf8\xb5\x4a\x00\x85\x63\xc6\x0b\x41\x35\x67\x54\xf0\xff\x66\x0a\x1e\x41\xf3\xff\x1d\xaa\xc6\x07" +
			"\x7e\xa6\x69\x64\xac\x36\xdc\xef\xdd\xa6\x70\xb6\x30\x05\xca\x50\xb1\x4a\x3f\xfd\x50\xeb\x4c\xa5" +
			"\xc0\xd3\xb3\xad\x1f\x9f\x38\x1f\xda\xb6\xfa\x06\xb2\x2b\xa3\xb6\x05\xa5\x23\x78\x87\xfd\xbf\xc2" +
			"\x9e\xc8\xe8\x5d\x54\x1f\xb3\x23\xe7\x2b\x2d\x4e\x85\xf2\xcd\xaa\x6d\xd7\x1e\xcf\xe6\xf3\xe7\x33" +
			"\xc1\x7c\x59\x99\x85\xab\xe6\xa5\x94\xab\xef\xe2\xdb\xd2\xe3\xbf\x77\x7d\x61\x6d\xb0\xbc\xc9\xe3" +
			"\xcf\x44\x02\x62\xa2\x90\xd5\xeb\x1d\x6c\x77\xf1\xc5\xaa\xe8\x3d\x06\xfd\x0a\x93\x9a\xe2\xb2\x02" +
			"\x6c\x01\x1b\x0a\xa3\x73\xa4\xeb\xdd\x9f\x00\x00\x00\xff\xff",
		size: 849,
		mode: 0664,
		time: time.Unix(1533174510, 152788160),
	},
}

// AssetAndInfo loads and returns the asset and asset info for the
// given name. It returns an error if the asset could not be found
// or could not be loaded.
func AssetAndInfo(name string) ([]byte, os.FileInfo, error) {
	a, ok := _bindata[filepath.ToSlash(name)]
	if !ok {
		return nil, nil, &os.PathError{Op: "open", Path: name, Err: os.ErrNotExist}
	}

	a.once.Do(func() {
		fr := flate.NewReader(strings.NewReader(a.data))

		var buf bytes.Buffer
		if _, a.err = io.Copy(&buf, fr); a.err != nil {
			return
		}

		if a.err = fr.Close(); a.err == nil {
			a.bytes = buf.Bytes()
		}
	})
	if a.err != nil {
		return nil, nil, &os.PathError{Op: "read", Path: name, Err: a.err}
	}

	return a.bytes, a, nil
}

// AssetInfo loads and returns the asset info for the given name.
// It returns an error if the asset could not be found or
// could not be loaded.
func AssetInfo(name string) (os.FileInfo, error) {
	a, ok := _bindata[filepath.ToSlash(name)]
	if !ok {
		return nil, &os.PathError{Op: "open", Path: name, Err: os.ErrNotExist}
	}

	return a, nil
}

// Asset loads and returns the asset for the given name.
// It returns an error if the asset could not be found or
// could not be loaded.
func Asset(name string) ([]byte, error) {
	data, _, err := AssetAndInfo(name)
	return data, err
}

// MustAsset is like Asset but panics when Asset would return an error.
// It simplifies safe initialization of global variables.
func MustAsset(name string) []byte {
	a, err := Asset(name)
	if err != nil {
		panic("asset: Asset(" + name + "): " + err.Error())
	}

	return a
}

// AssetNames returns the names of the assets.
func AssetNames() []string {
	names := make([]string, 0, len(_bindata))
	for name := range _bindata {
		names = append(names, name)
	}

	return names
}

// RestoreAsset restores an asset under the given directory
func RestoreAsset(dir, name string) error {
	return restore.Asset(dir, name, AssetAndInfo)
}

// RestoreAssets restores an asset under the given directory recursively
func RestoreAssets(dir, name string) error {
	return restore.Assets(dir, name, AssetDir, AssetAndInfo)
}

// AssetDir returns the file names below a certain
// directory embedded in the file by go-bindata.
// For example if you run go-bindata on data/... and data contains the
// following hierarchy:
//     data/
//       foo.txt
//       img/
//         a.png
//         b.png
// then AssetDir("data") would return []string{"foo.txt", "img"}
// AssetDir("data/img") would return []string{"a.png", "b.png"}
// AssetDir("foo.txt") and AssetDir("notexist") would return an error
// AssetDir("") will return []string{"data"}.
func AssetDir(name string) ([]string, error) {
	node := _bintree

	if name != "" {
		var ok bool
		for _, p := range strings.Split(filepath.ToSlash(name), "/") {
			if node, ok = node[p]; !ok {
				return nil, &os.PathError{Op: "open", Path: name, Err: os.ErrNotExist}
			}
		}
	}

	if len(node) == 0 {
		return nil, &os.PathError{Op: "open", Path: name, Err: os.ErrNotExist}
	}

	rv := make([]string, 0, len(node))
	for name := range node {
		rv = append(rv, name)
	}

	return rv, nil
}

type bintree map[string]bintree

var _bintree = bintree{
	"config.snc": bintree{},
}
